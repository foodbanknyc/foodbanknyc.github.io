<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>NYC CDTA: ACS 5-year Choropleth</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- MapLibre -->
  <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>

  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #map { position: absolute; inset: 0; background: #fff; }

    .panel {
      position: absolute; top: 12px; left: 12px; z-index: 2;
      background: rgba(255,255,255,0.96); padding: 12px; border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12); width: 520px;
    }
    .row { display: flex; gap: 8px; align-items: center; margin: 8px 0; }
    label { font-size: 12px; color: #333; min-width: 110px; }
    select, button { flex: 1; padding: 8px; border-radius: 10px; border: 1px solid #ddd; }

    .legend { margin-top: 10px; font-size: 12px; color: #333; }
    .bar { height: 10px; border-radius: 999px; background: linear-gradient(90deg, #ffffff, #b30000); border: 1px solid #eee; }
    .status { font-size: 12px; color: #333; margin-top: 8px; white-space: pre-line; line-height: 1.25; }
    .hint { font-size: 12px; color: #555; margin-top: 8px; line-height: 1.35; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; font-size: 12px; color:#333; }
    .small { font-size: 11px; color: #444; margin-top: 6px; }
  </style>
</head>

<body>
  <div id="map"></div>

  <div class="panel">
    <div class="row">
      <label for="metric">Metric</label>
      <select id="metric">
        <option value="poverty" selected>Poverty %</option>
        <option value="snap">SNAP % (households)</option>
        <option value="unemp">Unemployment % (labor force)</option>
      </select>
    </div>

    <div class="row">
      <label for="pop">Population</label>
      <select id="pop"></select>
    </div>

    <div class="row">
      <label for="year">ACS Year</label>
      <select id="year">
        <option value="2024" selected>2024 (ACS 5-year)</option>
        <option value="2023">2023 (ACS 5-year)</option>
        <option value="2022">2022 (ACS 5-year)</option>
        <option value="2021">2021 (ACS 5-year)</option>
      </select>
    </div>

    <div class="row">
      <button id="reload" type="button">Load / Refresh</button>
    </div>

    <div class="legend">
      <div class="bar"></div>
      <div style="display:flex; justify-content:space-between; margin-top:4px;">
        <span>low</span><span>high</span>
      </div>
      <div class="small">No-data CDTAs are shown in light gray.</div>
    </div>

    <div class="status" id="status">Booting…</div>
    <div class="mono" id="debug"></div>

    <div class="hint">
      Notes:
      <ul style="margin:6px 0 0 18px; padding:0;">
        <li>All outputs are <b>ACS 5-year</b> estimates aggregated tract → CDTA.</li>
        <li>Some CDTAs may have <b>no tract rows</b> in the equivalency (e.g., excluded water tracts), so they will always be “No data”.</li>
      </ul>
    </div>
  </div>

<script>
(() => {
  // ----------------------------
  // White basemap
  // ----------------------------
  const POSITRON_STYLE = {
    "version": 8,
    "sources": {
      "carto": {
        "type": "raster",
        "tiles": [
          "https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png",
          "https://b.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png",
          "https://c.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png",
          "https://d.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png"
        ],
        "tileSize": 256,
        "attribution": "© OpenStreetMap contributors © CARTO"
      }
    },
    "layers": [
      { "id": "bg", "type": "background", "paint": { "background-color": "#ffffff" } },
      { "id": "carto", "type": "raster", "source": "carto" }
    ]
  };

  // ----------------------------
  // Data sources
  // ----------------------------
  const CDTA_ARCGIS_GEOJSON_URL =
    "https://services5.arcgis.com/GfwWNkhOj9bNBqoJ/arcgis/rest/services/NYC_Community_District_Tabulation_Areas_2020/FeatureServer/0/query" +
    "?where=1%3D1&outFields=*&f=geojson&outSR=4326";

  const CDTA_SOCRATA_GEOJSON_URL =
    "https://data.cityofnewyork.us/resource/xrfd-bjik.geojson?$limit=5000";

  const TRACT_TO_CDTA_CSV_URL =
    "https://data.cityofnewyork.us/resource/hm78-6dwm.csv?$limit=50000";

  const NYC_COUNTY_FIPS = ["005","047","061","081","085"];
  const NY_STATE_FIPS = "36";

  // ----------------------------
  // UI populations by metric
  // ----------------------------
  const POP_OPTIONS = {
    poverty: [
      ["all", "Total (all people)"],
      ["women", "Women (all ages)"],
      ["children", "Children (<18)"],
      ["black", "Black / African American"],
      ["asian", "Asian"],
      ["hisp", "Hispanic/Latino (any race)"]
    ],
    snap: [
      ["all", "Total (all households)"],
      ["black", "Black householder"],
      ["asian", "Asian householder"],
      ["hisp", "Hispanic/Latino householder"]
    ],
    unemp: [
      ["all", "Total (labor force)"]
    ]
  };

  // ----------------------------
  // DOM helpers
  // ----------------------------
  const STATUS = (msg) => (document.getElementById("status").textContent = msg);
  const DEBUG  = (msg) => (document.getElementById("debug").innerHTML = msg);

  // ----------------------------
  // Robust fetch (retries + backoff)
  // ----------------------------
  async function fetchText(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
    return await r.text();
  }

  async function fetchJsonRobust(url, tries = 3) {
    let lastErr = null;

    for (let attempt = 1; attempt <= tries; attempt++) {
      try {
        const r = await fetch(url, { cache: "no-store" });
        if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);

        const txt = await r.text();
        if (!txt || txt.trim().length < 2) throw new Error(`Empty/truncated response for ${url}`);

        return JSON.parse(txt);
      } catch (e) {
        lastErr = e;
        console.warn(`fetchJsonRobust attempt ${attempt}/${tries} failed`, e);
        const delay = attempt === 1 ? 250 : attempt === 2 ? 750 : 1500;
        await new Promise(res => setTimeout(res, delay));
      }
    }

    throw lastErr;
  }

  // ----------------------------
  // CSV parsing (quoted headers + quoted fields)
  // ----------------------------
  function parseCsvLine(line) {
    const out = [];
    let cur = "";
    let inQuotes = false;

    for (let i = 0; i < line.length; i++) {
      const ch = line[i];

      if (ch === '"') {
        if (inQuotes && line[i + 1] === '"') { cur += '"'; i++; }
        else inQuotes = !inQuotes;
      } else if (ch === "," && !inQuotes) {
        out.push(cur); cur = "";
      } else {
        cur += ch;
      }
    }
    out.push(cur);
    return out.map(s => s.trim());
  }

  function stripOuterQuotes(s) {
    return String(s ?? "").replace(/^"(.*)"$/, "$1").trim();
  }

  function csvToRows(csvText) {
    const lines = csvText.trim().split(/\r?\n/);
    if (lines.length < 2) return [];

    const headers = parseCsvLine(lines[0]).map(h => stripOuterQuotes(h).toLowerCase());
    const rows = [];

    for (const line of lines.slice(1)) {
      if (!line.trim()) continue;
      const cols = parseCsvLine(line);
      const obj = {};
      headers.forEach((h, i) => obj[h] = stripOuterQuotes(cols[i] ?? ""));
      rows.push(obj);
    }
    return rows;
  }

  // ----------------------------
  // Math helpers
  // ----------------------------
  function toPct(numer, denom) {
    if (!Number.isFinite(numer) || !Number.isFinite(denom) || denom <= 0) return null;
    return (numer / denom) * 100.0;
  }

  function formatValue(v) {
    if (!Number.isFinite(v)) return "No data";
    return `${v.toFixed(1)}%`;
  }

  // ----------------------------
  // Census API helpers
  // ----------------------------
  function censusUrl({year, dataset, vars, countyFips}) {
    const base = `https://api.census.gov/data/${year}/${dataset}`;
    const get = ["NAME", ...vars].join(",");
    return `${base}?get=${encodeURIComponent(get)}&for=tract:*&in=state:${NY_STATE_FIPS}%20county:${countyFips}`;
  }

  // ----------------------------
  // Crosswalk cache (avoid refetch per refresh)
  // ----------------------------
  let geoidToCdtaCache = null;

  async function loadCrosswalkGeoidToCdta() {
    STATUS("Loading tract→CDTA crosswalk…");
    const csv = await fetchText(TRACT_TO_CDTA_CSV_URL);
    const rows = csvToRows(csv);
    if (!rows.length) throw new Error("Crosswalk returned 0 rows");

    const keys = Object.keys(rows[0]);
    console.log("Crosswalk headers:", keys);
    if (!keys.includes("geoid") || !keys.includes("cdtacode")) {
      throw new Error("Could not find geoid/cdtacode in crosswalk (after cleaning).");
    }

    const m = new Map();
    for (const r of rows) {
      const geoid = (r.geoid || "").trim();
      const cdta = (r.cdtacode || "").trim().toUpperCase();
      if (geoid && cdta) m.set(geoid, cdta);
    }
    return m;
  }

  async function getGeoidToCdta() {
    if (geoidToCdtaCache) return geoidToCdtaCache;
    geoidToCdtaCache = await loadCrosswalkGeoidToCdta();
    return geoidToCdtaCache;
  }

  // ----------------------------
  // CDTA geometry (ArcGIS primary, Socrata fallback)
  // ----------------------------
  function normalizeCdtaFeatureProps(geo) {
    for (const f of geo.features || []) {
      const p = f.properties || {};
      f.properties = p;

      p.cdta_code = String(
        p.cdtacode || p.CDTACODE || p.cdta2020 || p.CDTA2020 || p.CDTA2020 || p.CDTA2020 || p.CDTA2020 ||
        p.CDTA2020 || p.CDTA2020 || p.CDTA2020 || p.CDTA2020 ||
        p.CDTA2020 || p.CDTA2020 || p.CDTA2020 ||
        p.CDTA2020 || p.CDTA2020 || p.CDTA2020 ||
        p.CDTA2020 || p.CDTA2020 ||
        p.CDTA2020 || p.CDTA2020 ||
        p.CDTA2020 || p.CDTA2020 ||
        p.CDTA2020 || p.CDTA2020 ||
        p.CDTA2020 || p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.CDTA2020 ||
        p.GEOID || p.geoid || ""
      ).trim().toUpperCase();

      p.cdta_name = String(
        p.cdtaname || p.CDTANAME || p.CDTAName || p.cdtaname2020 || p.NAME || p.name || ""
      ).trim();
    }
    return geo;
  }

  async function loadCdtaGeo() {
    STATUS("Loading CDTA boundaries…");
    try {
      let geo = await fetchJsonRobust(CDTA_ARCGIS_GEOJSON_URL, 3);
      geo = normalizeCdtaFeatureProps(geo);
      return geo;
    } catch (e) {
      console.warn("ArcGIS CDTA load failed, trying Socrata…", e);
    }

    let geo = await fetchJsonRobust(CDTA_SOCRATA_GEOJSON_URL, 3);
    geo = normalizeCdtaFeatureProps(geo);
    return geo;
  }

  // ----------------------------
  // Metric specs (tract-level)
  // ----------------------------
  function povertyTableForPop(pop) {
    if (pop === "black") return "B17001B";
    if (pop === "asian") return "B17001D";
    if (pop === "hisp")  return "B17001I"; // Hispanic/Latino any race
    return "B17001";
  }

  function povertyVarsForPop(pop) {
    if (pop === "all" || pop === "black" || pop === "asian" || pop === "hisp") {
      return { vars: ["B17001_001E", "B17001_002E"], numer: ["B17001_002E"], denom: ["B17001_001E"] };
    }
    if (pop === "women") {
      return { vars: ["B17001_017E", "B17001_046E"], numer: ["B17001_017E"], denom: ["B17001_017E","B17001_046E"] };
    }
    if (pop === "children") {
      const below = ["B17001_004E","B17001_005E","B17001_006E","B17001_007E","B17001_008E","B17001_009E",
                     "B17001_018E","B17001_019E","B17001_020E","B17001_021E","B17001_022E","B17001_023E"];
      const above = ["B17001_033E","B17001_034E","B17001_035E","B17001_036E","B17001_037E","B17001_038E",
                     "B17001_047E","B17001_048E","B17001_049E","B17001_050E","B17001_051E","B17001_052E"];
      return { vars: [...below, ...above], numer: below, denom: [...below, ...above] };
    }
    throw new Error("Unsupported poverty pop: " + pop);
  }

  function snapSpecForPop(pop) {
    if (pop === "all") {
      return { dataset: "acs/acs5", vars: ["B22005_001E","B22005_002E"], numer:"B22005_002E", denom:"B22005_001E" };
    }
    if (pop === "black") {
      return { dataset: "acs/acs5", vars: ["B22005B_001E","B22005B_002E"], numer:"B22005B_002E", denom:"B22005B_001E" };
    }
    if (pop === "asian") {
      return { dataset: "acs/acs5", vars: ["B22005D_001E","B22005D_002E"], numer:"B22005D_002E", denom:"B22005D_001E" };
    }
    if (pop === "hisp") {
      return { dataset: "acs/acs5", vars: ["B22005I_001E","B22005I_002E"], numer:"B22005I_002E", denom:"B22005I_001E" };
    }
    throw new Error("Unsupported SNAP pop: " + pop);
  }

  function unempSpecAllOnly() {
    return { dataset: "acs/acs5", vars: ["B23025_003E","B23025_005E"], numer:"B23025_005E", denom:"B23025_003E" };
  }

  // ----------------------------
  // Load tract data (sequential counties)
  // ----------------------------
  async function loadTractData({metric, pop, year}) {
    STATUS(`Fetching ${metric} (${pop}) from Census API…`);

    const out = new Map(); // GEOID -> {numer, denom}

    for (const county of NYC_COUNTY_FIPS) {
      if (metric === "poverty") {
        const table = povertyTableForPop(pop);
        const spec = povertyVarsForPop(pop);

        const vars = spec.vars.map(v => v.replace(/^B17001_/, `${table}_`));
        const numerVars = spec.numer.map(v => v.replace(/^B17001_/, `${table}_`));
        const denomVars = spec.denom.map(v => v.replace(/^B17001_/, `${table}_`));

        const url = censusUrl({year, dataset: "acs/acs5", vars, countyFips: county});
        const data = await fetchJsonRobust(url, 3);
        const h = data[0];

        const idx = {};
        for (const v of vars) idx[v] = h.indexOf(v);
        const iTr = h.indexOf("tract"), iCo = h.indexOf("county"), iSt = h.indexOf("state");

        for (const row of data.slice(1)) {
          const geoid = `${row[iSt]}${row[iCo]}${row[iTr]}`;
          let numer = 0, denom = 0;
          for (const nv of numerVars) numer += Number(row[idx[nv]]) || 0;
          for (const dv of denomVars) denom += Number(row[idx[dv]]) || 0;
          out.set(geoid, { numer, denom });
        }
        continue;
      }

      if (metric === "snap") {
        const s = snapSpecForPop(pop);
        const url = censusUrl({year, dataset: s.dataset, vars: s.vars, countyFips: county});
        const data = await fetchJsonRobust(url, 3);
        const h = data[0];

        const iDen = h.indexOf(s.denom);
        const iNum = h.indexOf(s.numer);
        const iTr = h.indexOf("tract"), iCo = h.indexOf("county"), iSt = h.indexOf("state");

        for (const row of data.slice(1)) {
          const geoid = `${row[iSt]}${row[iCo]}${row[iTr]}`;
          out.set(geoid, { numer: Number(row[iNum]), denom: Number(row[iDen]) });
        }
        continue;
      }

      if (metric === "unemp") {
        const s = unempSpecAllOnly();
        const url = censusUrl({year, dataset: s.dataset, vars: s.vars, countyFips: county});
        const data = await fetchJsonRobust(url, 3);
        const h = data[0];

        const iDen = h.indexOf(s.denom);
        const iNum = h.indexOf(s.numer);
        const iTr = h.indexOf("tract"), iCo = h.indexOf("county"), iSt = h.indexOf("state");

        for (const row of data.slice(1)) {
          const geoid = `${row[iSt]}${row[iCo]}${row[iTr]}`;
          out.set(geoid, { numer: Number(row[iNum]), denom: Number(row[iDen]) });
        }
        continue;
      }

      throw new Error("Unknown metric: " + metric);
    }

    return out;
  }

  // ----------------------------
  // Aggregate tract -> CDTA
  // ----------------------------
  function aggregateToCdta({tractMap, geoidToCdta}) {
    const agg = new Map(); // cdta -> {numerSum, denomSum}
    for (const [geoid, nd] of tractMap.entries()) {
      const cdta = geoidToCdta.get(geoid);
      if (!cdta) continue;
      const cur = agg.get(cdta) || { numerSum: 0, denomSum: 0 };
      cur.numerSum += Number.isFinite(nd.numer) ? nd.numer : 0;
      cur.denomSum += Number.isFinite(nd.denom) ? nd.denom : 0;
      agg.set(cdta, cur);
    }
    const out = new Map();
    for (const [cdta, s] of agg.entries()) out.set(cdta, toPct(s.numerSum, s.denomSum));
    return out;
  }

  // ----------------------------
  // Stable color ramp (min -> max) + explicit no-data gray
  // ----------------------------
  function applyRedRampFromMinMax(values) {
    if (!map.getLayer("cdta-fill")) return;

    const finite = values.filter(Number.isFinite);
    if (!finite.length) {
      map.setPaintProperty("cdta-fill", "fill-color", "#f2f2f2");
      return;
    }

    const min = Math.min(...finite);
    const max = Math.max(...finite);
    const hi = (min === max) ? (max + 1e-6) : max;

    map.setPaintProperty("cdta-fill", "fill-color", [
      "case",
      ["!", ["has", "value"]], "#f2f2f2",
      ["==", ["get", "value"], null], "#f2f2f2",
      ["interpolate", ["linear"], ["get", "value"],
        min, "#ffffff",
        hi,  "#b30000"
      ]
    ]);
  }

  // ----------------------------
  // Labels
  // ----------------------------
  function labelFor(metric, pop, year) {
    const popLabel = (POP_OPTIONS[metric] || []).find(x => x[0] === pop)?.[1] || pop;
    const y = `${year} (ACS 5-year)`;
    if (metric === "poverty") return `Poverty % • ${popLabel} • ${y}`;
    if (metric === "snap")    return `SNAP % • ${popLabel} • ${y}`;
    if (metric === "unemp")   return `Unemployment % • ${popLabel} • ${y}`;
    return `${metric} • ${popLabel} • ${y}`;
  }

  // ----------------------------
  // UI population selector
  // ----------------------------
  function setPopOptions(metric) {
    const popSel = document.getElementById("pop");
    const prev = popSel.value;
    popSel.innerHTML = "";

    for (const [val, label] of POP_OPTIONS[metric] || []) {
      const opt = document.createElement("option");
      opt.value = val;
      opt.textContent = label;
      popSel.appendChild(opt);
    }

    const stillValid = [...popSel.options].some(o => o.value === prev);
    popSel.value = stillValid ? prev : (POP_OPTIONS[metric]?.[0]?.[0] ?? "all");
  }

  // ----------------------------
  // Map init
  // ----------------------------
  const map = new maplibregl.Map({
    container: "map",
    style: POSITRON_STYLE,
    center: [-73.94, 40.70],
    zoom: 9.6
  });
  map.addControl(new maplibregl.NavigationControl(), "bottom-right");

  let cdtaGeo = null;
  
function displayCdtaName(code, rawName) {
  const c = String(code || "").trim().toUpperCase();
  let n = String(rawName || "").trim();

  // If name starts with the code (e.g., "BK55 Prospect Park ..."), strip it
  if (c && n.toUpperCase().startsWith(c + " ")) {
    n = n.slice(c.length + 1).trim();
  }

  // Remove trailing "(... Approximation)" or "(... Equivalent)"
  // Examples: "(JIA 55 Approximation)", "(JIA 64 Equivalent)"
  n = n.replace(/\s*\([^)]*(Approximation|Equivalent)[^)]*\)\s*$/i, "").trim();

  return { code: c, name: n };
}


  // ----------------------------
  // Render
  // ----------------------------
  async function render() {
    const metric = document.getElementById("metric").value;
    const pop = document.getElementById("pop").value;
    const year = document.getElementById("year").value;

    STATUS("Loading…");
    DEBUG("");

    if (!map.getSource("cdta") || !map.getLayer("cdta-fill")) {
      STATUS("Map not ready yet…");
      return;
    }

    const [geoidToCdta, tractMap] = await Promise.all([
      getGeoidToCdta(),
      loadTractData({metric, pop: document.getElementById("pop").value, year})
    ]);

    const cdtaVals = aggregateToCdta({ tractMap, geoidToCdta });

    let matched = 0;
    const values = [];
    const missing = [];

    for (const f of cdtaGeo.features || []) {
      const code = (f.properties?.cdta_code || "").trim().toUpperCase();
      const name = (f.properties?.cdta_name || "").trim();

      const v = cdtaVals.get(code);
      f.properties.value = (v === undefined ? null : v);

      const dn = displayCdtaName(code, name);

      if (Number.isFinite(v)) { matched++; values.push(v); }
      else missing.push(`${dn.code || "(blank)"}${dn.name ? " • " + dn.name : ""}`);

    }

    map.getSource("cdta").setData(cdtaGeo);
    applyRedRampFromMinMax(values);

    const min = values.length ? Math.min(...values) : null;
    const max = values.length ? Math.max(...values) : null;

    console.log("Matched CDTAs:", matched, "of", cdtaGeo.features.length, "values:", values.length);

    STATUS(
      `${labelFor(metric, document.getElementById("pop").value, year)}\n` +
      `Matched CDTAs with data: ${matched}/${cdtaGeo.features.length}\n` +
      `All outputs: ACS 5-year (tract → CDTA aggregation)`
    );

    const showMissing = missing
      .filter(x => !x.startsWith("(blank)"))
      .slice(0, 12)
      .map(x => x.replace(/</g,"&lt;").replace(/>/g,"&gt;"));

    DEBUG(
      `Value count: ${values.length}<br>` +
      `Min/Max: ${min == null ? "n/a" : `${min.toFixed(2)} / ${max.toFixed(2)}`}` +
      `<br><br><b>No-data CDTAs (sample):</b><br>${showMissing.join("<br>")}` +
      (missing.length > showMissing.length ? `<br>…and ${missing.length - showMissing.length} more` : "")
    );
  }

  // ----------------------------
  // Events
  // ----------------------------
  document.getElementById("metric").addEventListener("change", () => {
    setPopOptions(document.getElementById("metric").value);
    render().catch(err => { console.error(err); STATUS("Render failed (see console)."); DEBUG(String(err)); });
  });
  document.getElementById("pop").addEventListener("change", () => {
    render().catch(err => { console.error(err); STATUS("Render failed (see console)."); DEBUG(String(err)); });
  });
  document.getElementById("year").addEventListener("change", () => {
    render().catch(err => { console.error(err); STATUS("Render failed (see console)."); DEBUG(String(err)); });
  });
  document.getElementById("reload").addEventListener("click", () => {
    render().catch(err => { console.error(err); STATUS("Render failed (see console)."); DEBUG(String(err)); });
  });

  // ----------------------------
  // Map load
  // ----------------------------
  map.on("load", async () => {
    try {
      setPopOptions(document.getElementById("metric").value);
      cdtaGeo = await loadCdtaGeo();

      map.addSource("cdta", { type: "geojson", data: cdtaGeo });

      map.addLayer({
        id: "cdta-fill",
        type: "fill",
        source: "cdta",
        paint: { "fill-color": "#f2f2f2", "fill-opacity": 0.88 }
      });

      map.addLayer({
        id: "cdta-line",
        type: "line",
        source: "cdta",
        paint: { "line-width": 1.1, "line-color": "#555", "line-opacity": 0.75 }
      });

      const popup = new maplibregl.Popup({ closeButton: false, closeOnClick: false });

    map.on("mousemove", "cdta-fill", (e) => {
    map.getCanvas().style.cursor = "pointer";
    const f = e.features?.[0];
    if (!f) return;

    const code = f.properties?.cdta_code ?? "";
    const rawName = f.properties?.cdta_name ?? "";
    const dn = displayCdtaName(code, rawName);

    const v = f.properties?.value;

    popup.setLngLat(e.lngLat).setHTML(`
        <div style="font-size:12px;">
        <div style="font-weight:700; margin-bottom:4px;">${dn.code}${dn.name ? " • " + dn.name : ""}</div>
        <div>${formatValue(v)}</div>
        </div>
    `).addTo(map);
    });


      map.on("mouseleave", "cdta-fill", () => {
        map.getCanvas().style.cursor = "";
        popup.remove();
      });

      map.fitBounds([[-74.30, 40.47], [-73.68, 40.95]], { padding: 20, duration: 300 });

      await render();
    } catch (err) {
      console.error(err);
      STATUS("Startup failed (see console).");
      DEBUG(String(err));
    }
  });

})();
</script>
</body>
</html>
